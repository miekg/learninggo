{.exercise data-difficulty="2"}
### Fibonacci II

This is the same exercise as an earlier one (#fibonacci) in
exercise. For completeness the complete question:

> The Fibonacci sequence starts as follows: $1, 1, 2, 3, 5, 8, 13, \ldots$
> Or in mathematical terms:
> $x_1 = 1; x_2 = 1; x_n = x_{n-1} + > x_{n-2}\quad\forall n > 2$.
>
> Write a function that takes an `int` value and gives
> that many terms of the Fibonacci sequence.

*But* now the twist: You must use channels.

### Answer

The following program calculates the Fibonacci numbers using channels.

~~~go
package main
import "fmt"

// Duplicate3 duplicates the input channel `in` three times.
func duplicate3(in <-chan int) (<-chan int, <-chan int, <-chan int) {
    out1, out2, out3 := make(chan int, 2), make(chan int, 2), make(chan int, 2) // <<1>>

    go func() { // <<2>>
        for {
            num := <-in
            
            out1 <- num
            out2 <- num
            out3 <- num
        }
    }()

    return out1, out2, out3
}

// Generate a stream of Fibonacci numbers using the input channel `x`.
func fib(x chan<- int) <-chan int {
    fibonacciOut := make(chan int, 2)

    a, b, c := duplicate3(fibonacciOut)

    go func() { // <<3>>
        x <- 0
        x <- 1

        <-a // <<4>>

        // <<5>>
        for {
            num := <-a + <-b
            fibonacciOut <- num
        }
    }()

    return c
}

func main() {
    output := fib(x) // <<6>>

    for i := 0; i < 10; i++ {
        fmt.Println(<-output) // <<6>>
    }
}

// Adapted code from sdh33b.blogspot.com/2009/12/fibonacci-in-go.html
// Adapted by: [ryrden](https://github.com/ryrden)
~~~

The duplicate3 function at <<1>> creates three buffered output channels with a capacity of 2. This allows the function to write to each output channel twice before blocking, potentially improving performance by allowing the goroutine to write to multiple channels without waiting for each write to complete. At <<2>>, a goroutine is started to read from the input channel and write to the three output channels.

The function fib at <<3>> takes an output channel of integers and generates the Fibonacci sequence by repeatedly summing the previous two numbers. It uses the duplicate3 function to split the output channel into three separate streams.

In the main function, <<6>> a call to fib function with an output channel starts the generation of the Fibonacci sequence. The function returns one of the three output channels from duplicate3, which is then used to print the first 10 numbers of the sequence.

At <<4>>, we need to ignore the first number generated by the sequence because the definition of the Fibonacci sequence starts with $1, 1, 2, 3, 5, 8, 13, \ldots$. At <<5>>, the subsequent numbers are generated and written to the output channel.

Note that using buffered channels can improve the performance of the program by allowing goroutines to write to multiple channels without blocking. However, the buffer size should be chosen carefully to avoid excessive memory usage.
